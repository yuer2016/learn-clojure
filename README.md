# learn-clojure

任何足够复杂的 C 语言或者 Fortran 程序中,都包含一个临时特设的、不合规范的、充满程序错误的、运行速度很慢的、只有一半功能的 Common-Lisp 实现。

Clojure 语法相关的关键点:

1. 前缀表示法
2. 空格与注释
3. 大小写敏感性

Clojure 代码用 Clojure 数据结构表示。

## doc find-doc 和 apropos 查找文档

```clojure
;; 搜索与任何其他函数或者宏相关的文档。
;; 该宏接受你要了解的实体名称
(doc +)
(doc str)

;; find-doc 函数接受一个字符串参数，这个参数可以是正则表达式 regex 。
;; 该函数按照名称或者相关文档与所提供模式的匹配寻找符合条件的函数或宏文档
(find-doc "lazy")

;; apropos 是一个与文档相关的函数，其工作方式与 find-doc 非常类似，但是只打印匹配搜索模式的函数名称
(apropos 'doc)
```

## 基础类型

Clojure 的 nil 等价于 Java 中的 null 它的含义是 **什么也没有**, Clojure 核心函数在 nil 上操作时会尽量输出合理的结果。

Clojure 字符是 Java 字符(无符号 16 位 UTF-16 代码), 它们用双引号表示 (单引号是一个读取器宏, 正如前面你所看到的,它代表的是完全不同的意义)

```clojure
(.contains "clojure-in-action" "-")

(.endsWith "learn.clj" ".clj")
```

Clojure 中使用的数值都是 64 位整数 (Java 原始长整数) 或者 64 位浮点数 (Java 原始双精度数)。
当需要更大的范围时，可以使用大整数（任意精度整数）或者大十进制数 (任意精度十进制数)。

Clojure 还增加了另一种不太常见的数值类型：比例(ratio)。
比例在两个整数相除时创建，它们不能被进一步简化 。

```clojure
(/ 4 9)
;;-> 4/9

(/ 10.0 3.0)
;;-> 3.3333333333333335
```

## 符号和关键字

符号是 Clojure 程序中的标识符，代表值的名称。
例如，在形式（+ 1 2）中，**+** 是代表加法函数的符号。

因为 Clojure 的 **读取和求值** 是 **分离** 的，所以符号有两个不同的特性：
读取之后的 **程序数据结构形式** 以及它们 **解出的值**。

符号本身只是包含可选命名空间的名称，但当一个表达式求值时，它们被所代表的值代替。

符号是字母数字字符或者如下字符的任意组合：*！_？$%&=<>。

符号不能以数字开头；如果以 -、+ 或者.开始，则第二个字符不能是数字（不会和数值字面量混淆）；

它们的中间（不能放在其他地方）可以使用一个 **/** 分隔命名空间和名称的各个部分。

当你为一个符号加上 **引号** 时，就将这个符号当成 **数据** 而不是 **代码** 来处理。

在实践中，你几乎绝不会为符号加上引号而当成数据使用，因为 Clojure 有一个特殊类型专门用于这种用例：**关键字**。
**关键字** 就像是自动加上引号的符号：关键字从不引用其他值，求值的结果总是它们自身。

可以用 keyword 和 symbol 函数从字符串中构造 **关键字** 和 **符号**，这两个函数的参数是一个名称字符串和可选的命名空间字符串。
可以用 name 和 namespace 函数检查关键字和函数

```clojure
'abcd
;;-> abcd

;;关键字
:abc
;;-> :abc

(keyword "foo")
;;-> :foo

(symbol "foo" "bar")
;;-> foo/bar

(name :foo/bar)
;;-> "bar"

(namespace :foo/bar)
;;-> foo
```

## 列表

列表是 Clojure 中的基本集合数据结构。Clojure 列表是单链表。
列表的特殊性在于，每个 Clojure 代码表达式都是一个列表。
该列表可能包含其他数据结构(如向量)，但是列表是最基本的。

```clojure
;; 用 list 函数可以创建一个列表。
(list 1 2 3 4 5)
;;-> (1 2 3 4 5)

;; list？函数可以测试列表类型，*1 是一个 Clojure 中的特殊变量，它始终引用最近一次 REPL 会话中计算的结果
(list? * 1)
;;-> true

;;用 conj 函数创建一个新列表并在其中添加另一个值
(conj (list 1 2 3 4 5) 6)
;;-> (6 1 2 3 4 5)

(conj (list 1 2 3) 4 5 6)
;;-> (6 5 4 1 2 3)

;; 可以将列表当成一个栈来对待。

;; 用 peek 返回表头，空列表时返回 nil
(peek (list 1 2 3))
;;-> 1

;; 用 pop 返回表尾，空列表时报错
(pop (list 1 2 3))
;;-> (2 3)

;;count 函数得到列表中的元素数量
(count (list 1 2 3))
;;-> 3

;; 当时希望将符号作为数据而非代码。解决方案也相同——加上引号
(def three-numbers '(1 2 3))
```

## 向量

向量和列表相同：向量用方括号表示，以数字作为索引。

向量可以用 vector 函数创建，也可以用方括号表示法创建。

向量用数字方法索引，你可以快速随机访问向量中的元素。

```clojure
(vector 10 11 12 13 14 15)
;;-> [10 11 12 13 14 15]

[10 11 12 13 14 15]
;;-> [10 11 12 13 14 15]

;; 获取向量元素的函数有 get 和 nth
;; 修改向量,最常用的是 assoc，
(def v-list '[10 11 12 13 14 15])

;; 如果没有找到对应的值, get 返回 nil
(get v-list 0)
;;-> 10

;; 如果没有找到对应的值, nth 抛出异常
(nth v-list 0)
;;-> 10

;; 该函数接受的参数是与新值相关的索引以及新值本身
(assoc v-list 0 25)
;;-> [25 11 12 13 14 15]

;;conj 函数也适用于向量。不同的是这一次新元素出现在序列的最后，这是向量中最快速的插入位置
(conj v-list 16)
;;-> [10 11 12 13 14 15 16]

;; peek 和 pop 也适用于向量，它们查看向量的尾部，而不是列表中的表头
(peek v-list)
;;-> 15

(pop v-list)
;;-> [10 11 12 13 14]

;; 向量有一个有趣的属性：它们是取单一参数的函数。
;; 这个参数被假定为一个索引，当用一个数字调用向量时，将在向量中查找与该索引相关的值
(v-list 2)
;;-> 12
```

## 映射

映射类似于 Python、Ruby 和 Perl 等语言中的关联数组或者字典。

一个映射就是一个 键-值 对序列。

键可以是任何类型的对象，用对应的键可以在映射中查到一个值。映射用花括号表示。

```clojure
(def the-map {:a 1 :b 2 :c 3})
;;-> #'user/the-map

;; 映射还可以用 hash-map 函数构建
(hash-map :a 1 :b 2 :c 3)
;;-> {:c 3, :b 2, :a 1}

;; 值的查找方式如下
(:a the-map)
;;-> 1

;; 若未找到关键字,可以指定一个默认值
(:z the-map 26)
;;-> 26

;; 有多个函数可以修改映射，常用的是 assoc 和 dissoc
(assoc the-map :d 4)
;;-> {:a 1, :b 2, :c 3, :d 4}

(dissoc the-map :a)
;;-> {:b 2, :c 3}

(def users {:tom {
  :date-joined "2023-06-20"
  :summary {
    :average {
      :monthly 1000
      :yearly 12000
    }
  }
}})

;; Clojure 提供了三个简化嵌套集合更新的函数
(assoc-in users [:tom :summary :average :monthly] 3000)
;;-> {:tom {:date-joined "2023-06-20", :summary {:average {:monthly 3000, :yearly 12000}}}}

(get-in users [:tom :summary :average :monthly])
;;-> 1000

(update-in users [:tom :summary :average :monthly] + 500)
;;-> {:tom {:date-joined "2023-06-20", :summary {:average {:monthly 1500, :yearly 12000}}}}
```

 映射字面量和 hash-map 函数不完全等价，因为 Clojure 实际上有两种不同的映射实现：哈希映射（hash-map）和数组映射（array-map）。
 数组映射以有序方式保存键和值，以扫描方式执行查找，而不采用哈希方式。
 这对于小的映射更快，所以较小的映射字面量（10个键或者更少）实际上将成为一个数组映射而不是哈希映射。
 如果用 assoc 函数将太多键关联到一个数组映射，那么最终将会得到一个哈希映射（但是，反过来却不成立：哈希映射变得太小时不会返回一个数组映射）。
 透明地替换数据结构的实现是 Clojure 提高性能的常用技巧，这是通过使用不可变数据结构和纯函数实现的。
 不管调用 hash-map 和 array-map 函数时使用多少个参数，它们总是返回对应的结构

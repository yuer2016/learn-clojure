# learn-clojure

任何足够复杂的 C 语言或者 Fortran 程序中,都包含一个临时特设的、不合规范的、充满程序错误的、运行速度很慢的、只有一半功能的 Common-Lisp 实现。

Clojure 语法相关的关键点:

1. 前缀表示法
2. 空格与注释
3. 大小写敏感性

Clojure 代码用 Clojure 数据结构表示。

## doc find-doc 和 apropos 查找文档

```clojure
;; 搜索与任何其他函数或者宏相关的文档。
;; 该宏接受你要了解的实体名称
(doc +)
(doc str)

;; find-doc 函数接受一个字符串参数，这个参数可以是正则表达式 regex 。
;; 该函数按照名称或者相关文档与所提供模式的匹配寻找符合条件的函数或宏文档
(find-doc "lazy")

;; apropos 是一个与文档相关的函数，其工作方式与 find-doc 非常类似，但是只打印匹配搜索模式的函数名称
(apropos 'doc)
```

## 基础类型

Clojure 的 nil 等价于 Java 中的 null 它的含义是 **什么也没有**, Clojure 核心函数在 nil 上操作时会尽量输出合理的结果。

Clojure 字符是 Java 字符(无符号 16 位 UTF-16 代码), 它们用双引号表示 (单引号是一个读取器宏, 正如前面你所看到的,它代表的是完全不同的意义)

```clojure
(.contains "clojure-in-action" "-")

(.endsWith "learn.clj" ".clj")
```

Clojure 中使用的数值都是 64 位整数 (Java 原始长整数) 或者 64 位浮点数 (Java 原始双精度数)。
当需要更大的范围时，可以使用大整数（任意精度整数）或者大十进制数 (任意精度十进制数)。

Clojure 还增加了另一种不太常见的数值类型：比例(ratio)。
比例在两个整数相除时创建，它们不能被进一步简化 。

```clojure
(/ 4 9)
;;-> 4/9

(/ 10.0 3.0)
;;-> 3.3333333333333335
```

## 符号和关键字

符号是 Clojure 程序中的标识符，代表值的名称。
例如，在形式（+ 1 2）中，**+** 是代表加法函数的符号。

因为 Clojure 的 **读取和求值** 是 **分离** 的，所以符号有两个不同的特性：
读取之后的 **程序数据结构形式** 以及它们 **解出的值**。

符号本身只是包含可选命名空间的名称，但当一个表达式求值时，它们被所代表的值代替。

符号是字母数字字符或者如下字符的任意组合：*！_？$%&=<>。

符号不能以数字开头；如果以 -、+ 或者.开始，则第二个字符不能是数字（不会和数值字面量混淆）；

它们的中间（不能放在其他地方）可以使用一个 **/** 分隔命名空间和名称的各个部分。

当你为一个符号加上 **引号** 时，就将这个符号当成 **数据** 而不是 **代码** 来处理。

在实践中，你几乎绝不会为符号加上引号而当成数据使用，因为 Clojure 有一个特殊类型专门用于这种用例：**关键字**。
**关键字** 就像是自动加上引号的符号：关键字从不引用其他值，求值的结果总是它们自身。

可以用 keyword 和 symbol 函数从字符串中构造 **关键字** 和 **符号**，这两个函数的参数是一个名称字符串和可选的命名空间字符串。
可以用 name 和 namespace 函数检查关键字和函数

```clojure
'abcd
;;-> abcd

;;关键字
:abc
;;-> :abc

(keyword "foo")
;;-> :foo

(symbol "foo" "bar")
;;-> foo/bar

(name :foo/bar)
;;-> "bar"

(namespace :foo/bar)
;;-> foo
```

## 列表

列表是 Clojure 中的基本集合数据结构。Clojure 列表是单链表。
列表的特殊性在于，每个 Clojure 代码表达式都是一个列表。
该列表可能包含其他数据结构(如向量)，但是列表是最基本的。

```clojure
;; 用 list 函数可以创建一个列表。
(list 1 2 3 4 5)
;;-> (1 2 3 4 5)

;; list？函数可以测试列表类型，*1 是一个 Clojure 中的特殊变量，它始终引用最近一次 REPL 会话中计算的结果
(list? * 1)
;;-> true

;;用 conj 函数创建一个新列表并在其中添加另一个值
(conj (list 1 2 3 4 5) 6)
;;-> (6 1 2 3 4 5)

(conj (list 1 2 3) 4 5 6)
;;-> (6 5 4 1 2 3)

;; 可以将列表当成一个栈来对待。

;; 用 peek 返回表头，空列表时返回 nil
(peek (list 1 2 3))
;;-> 1

;; 用 pop 返回表尾，空列表时报错
(pop (list 1 2 3))
;;-> (2 3)

;;count 函数得到列表中的元素数量
(count (list 1 2 3))
;;-> 3

;; 当时希望将符号作为数据而非代码。解决方案也相同——加上引号
(def three-numbers '(1 2 3))
```